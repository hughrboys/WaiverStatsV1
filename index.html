<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waiver Analytics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; padding: 20px; background-color: #f4f4f9; }
        .container { max_width: 900px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        h1 { margin-top: 0; color: #333; }
        .section { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .section h3 { margin-top: 0; }
        .row { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        label { width: 160px; font-weight: bold; }
        input[type="text"], input[type="number"], input[type="time"] { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }
        .file-group { background: #fafafa; padding: 10px; border-left: 5px solid #ccc; margin-bottom: 10px; }
        .blue-group { border-left-color: #4A90E2; }
        .green-group { border-left-color: #50E3C2; }
        button { background-color: #28a745; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer; width: 100%; }
        button:hover { background-color: #218838; }
        #stats { white-space: pre-wrap; background: #eee; padding: 10px; border-radius: 5px; margin-top: 20px; font-family: monospace; }
        canvas { margin-top: 20px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Waiver Analytics Tool</h1>

    <div class="section">
        <h3>1. Settings & Filters</h3>
        <div class="row">
            <label>Participants:</label>
            <input type="number" id="participants" value="10" style="width: 60px;">
        </div>
        <div class="row">
            <label>Filter Start Time:</label>
            <input type="time" id="filterStart">
            <span style="font-size: 0.8em; color: gray;">(Leave empty to auto-detect)</span>
        </div>
        <div class="row">
            <label>Filter End Time:</label>
            <input type="time" id="filterEnd">
        </div>
        <div class="row">
            <label>Hours Operational:</label>
            <input type="number" id="hours" placeholder="Calculated from filter">
        </div>
    </div>

    <div class="section">
        <h3>2. Upload Files</h3>
        
        <div class="file-group blue-group">
            <div class="row">
                <label>Blue Label:</label>
                <input type="text" id="label1" value="Waiver language 1">
            </div>
            <div class="row">
                <label>Select CSV:</label>
                <input type="file" id="file1" accept=".csv">
            </div>
        </div>

        <div class="file-group green-group">
            <div class="row">
                <label>Green Label:</label>
                <input type="text" id="label2" value="Waiver language 2">
            </div>
            <div class="row">
                <label>Select CSV:</label>
                <input type="file" id="file2" accept=".csv">
            </div>
        </div>
    </div>

    <button onclick="processData()">Generate Graph & Stats</button>

    <div id="stats"></div>
    <canvas id="myChart"></canvas>
</div>

<script>
    let chartInstance = null;

    function containsDigit(str) { return /\d/.test(str); }

    function parseDate(str) {
        if(!str) return null;
        const parts = str.split(' ');
        if(parts.length < 2) return null;
        const dateParts = parts[0].split('/');
        const timeParts = parts[1].split(':');
        if(dateParts.length < 3 || timeParts.length < 3) return null;
        return new Date(dateParts[2], dateParts[0]-1, dateParts[1], timeParts[0], timeParts[1], timeParts[2]);
    }

    function formatDateTime(dateObj) {
        const mm = (dateObj.getMonth() + 1).toString().padStart(2, '0');
        const dd = dateObj.getDate().toString().padStart(2, '0');
        const yyyy = dateObj.getFullYear();
        const hh = dateObj.getHours().toString().padStart(2, '0');
        const min = dateObj.getMinutes().toString().padStart(2, '0');
        return `${mm}/${dd}/${yyyy} ${hh}:${min}`;
    }

    function formatTimeOnly(dateObj) {
        const hh = dateObj.getHours().toString().padStart(2, '0');
        const min = dateObj.getMinutes().toString().padStart(2, '0');
        return `${hh}:${min}`;
    }

    function floorTo15Min(date) {
        const d = new Date(date);
        const min = d.getMinutes();
        const rem = min % 15;
        d.setMinutes(min - rem);
        d.setSeconds(0);
        d.setMilliseconds(0);
        return d;
    }

    // Helper to merge a specific HH:MM string into a base Date object
    function applyTimeFilter(baseDate, timeStr) {
        if (!timeStr) return null;
        const parts = timeStr.split(':');
        const d = new Date(baseDate);
        d.setHours(parseInt(parts[0]));
        d.setMinutes(parseInt(parts[1]));
        d.setSeconds(0);
        return d;
    }

    async function processData() {
        const file1Input = document.getElementById('file1');
        const file2Input = document.getElementById('file2');
        const label1 = document.getElementById('label1').value || "Group 1";
        const label2 = document.getElementById('label2').value || "Group 2";
        
        const p1 = file1Input.files[0] ? parseCSV(file1Input.files[0]) : Promise.resolve({rows:0, valid:0, intervals:{}, times:[]});
        const p2 = file2Input.files[0] ? parseCSV(file2Input.files[0]) : Promise.resolve({rows:0, valid:0, intervals:{}, times:[]});

        Promise.all([p1, p2]).then(results => {
            const [d1, d2] = results;

            if (d1.rows === 0 && d2.rows === 0) {
                alert("Please upload at least one CSV file.");
                return;
            }

            // --- 1. Determine Global Range & Handle Filters ---
            const allTimes = [...d1.times, ...d2.times];
            if (allTimes.length === 0) return;

            const globalMin = new Date(Math.min(...allTimes));
            const globalMax = new Date(Math.max(...allTimes));

            // UI Elements
            const filterStartInput = document.getElementById('filterStart');
            const filterEndInput = document.getElementById('filterEnd');
            const hoursInput = document.getElementById('hours');

            // If inputs are empty, auto-fill them with global min/max
            if (!filterStartInput.value) filterStartInput.value = formatTimeOnly(globalMin);
            if (!filterEndInput.value) filterEndInput.value = formatTimeOnly(globalMax);

            // Create Date objects for the Filter boundaries
            // We use the date from globalMin to ensure the date part matches the data
            const filterStartDt = applyTimeFilter(globalMin, filterStartInput.value);
            const filterEndDt = applyTimeFilter(globalMin, filterEndInput.value);

            // --- 2. Filter the Data ---
            // Combine all keys, sort them, then filter out ones outside the range
            const allKeys = new Set([...Object.keys(d1.intervals), ...Object.keys(d2.intervals)]);
            let sortedKeys = Array.from(allKeys).sort();

            // Apply Filter
            sortedKeys = sortedKeys.filter(k => {
                const t = parseInt(k);
                return t >= filterStartDt.getTime() && t <= filterEndDt.getTime();
            });

            // Recalculate Totals based on Filtered Keys
            let filteredValid1 = 0;
            let filteredValid2 = 0;
            sortedKeys.forEach(k => {
                filteredValid1 += (d1.intervals[k] || 0);
                filteredValid2 += (d2.intervals[k] || 0);
            });
            const totalFilteredValid = filteredValid1 + filteredValid2;

            // --- 3. Calculate Hours Operational based on Filter ---
            const calcHours = (filterEndDt - filterStartDt) / 1000 / 3600;
            hoursInput.value = calcHours.toFixed(2);

            // --- 4. Chart Title Data ---
            let filename = "";
            if (file1Input.files[0]) filename = file1Input.files[0].name;
            else if (file2Input.files[0]) filename = file2Input.files[0].name;
            
            const raceName = filename.split(" - ")[0] || "Combined Analytics";
            const dayName = globalMin.toLocaleDateString('en-US', { weekday: 'long' });
            const timeFrameStr = `Time frame: ${formatDateTime(filterStartDt)} - ${formatDateTime(filterEndDt)}`;
            const titleLines = [raceName, dayName, timeFrameStr];

            // --- 5. Dwell Time ---
            const participants = parseInt(document.getElementById('participants').value) || 10;
            let dwellStr = "N/A";
            
            if (totalFilteredValid > 0 && calcHours > 0) {
                const totalMins = (participants * calcHours * 60) / totalFilteredValid;
                const m = Math.floor(totalMins);
                const s = Math.round((totalMins - m) * 60);
                dwellStr = `${m}m ${s}s`;
            }

            // --- 6. Update Text ---
            const statsDiv = document.getElementById('stats');
            statsDiv.innerText = 
                `Total Participants (in filtered time): ${totalFilteredValid}\n` +
                `   - ${label1}: ${filteredValid1}\n` +
                `   - ${label2}: ${filteredValid2}\n` +
                `Hours Operational: ${calcHours.toFixed(2)}\n` +
                `Dwell Time: ${dwellStr}`;

            // --- 7. Render Chart ---
            renderChart(d1.intervals, d2.intervals, sortedKeys, label1, label2, titleLines);
        });
    }

    function parseCSV(file) {
        return new Promise((resolve) => {
            Papa.parse(file, {
                complete: function(results) {
                    let totalRows = 0;
                    let validCount = 0;
                    let intervalDict = {};
                    let rawTimes = [];

                    for (let i = 1; i < results.data.length; i++) {
                        const row = results.data[i];
                        if (row.length < 1) continue;
                        
                        const dt = parseDate(row[0]);
                        if (!dt) continue;

                        totalRows++;
                        rawTimes.push(dt.getTime());

                        let rowValid = 0;
                        [3, 5, 7, 9, 11, 13].forEach(idx => {
                            if (row[idx]) {
                                const val = row[idx].trim();
                                if (val && !containsDigit(val)) rowValid++;
                            }
                        });

                        validCount += rowValid;

                        const floored = floorTo15Min(dt).getTime();
                        intervalDict[floored] = (intervalDict[floored] || 0) + rowValid;
                    }
                    resolve({rows: totalRows, valid: validCount, intervals: intervalDict, times: rawTimes});
                }
            });
        });
    }

    function renderChart(dict1, dict2, sortedKeys, label1, label2, titleArray) {
        const ctx = document.getElementById('myChart').getContext('2d');
        
        // We now use the sortedKeys that have already been filtered in processData
        const labels = sortedKeys.map(k => {
            const d = new Date(parseInt(k));
            return d.getHours().toString().padStart(2,0) + ":" + d.getMinutes().toString().padStart(2,0);
        });

        const data1 = sortedKeys.map(k => dict1[k] || 0);
        const data2 = sortedKeys.map(k => dict2[k] || 0);

        if (chartInstance) chartInstance.destroy();

        chartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: label1,
                        data: data1,
                        backgroundColor: '#4A90E2',
                        stack: 'Stack 0',
                    },
                    {
                        label: label2,
                        data: data2,
                        backgroundColor: '#50E3C2',
                        stack: 'Stack 0',
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: titleArray,
                        font: { size: 16 },
                        padding: { top: 10, bottom: 20 },
                        color: '#333'
                    },
                    legend: { position: 'top' }
                },
                scales: {
                    x: { stacked: true, title: { display: true, text: 'Time (15-min intervals)' } },
                    y: { stacked: true, title: { display: true, text: 'Number of Participants' } }
                }
            }
        });
    }
</script>

</body>
</html>
